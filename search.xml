<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js获取高度宽度的方法]]></title>
    <url>%2F2018%2F08%2F23%2Fjs%E8%8E%B7%E5%8F%96%E9%AB%98%E5%BA%A6%E5%AE%BD%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[整理一下，js获取屏幕、视口或者DOM元素高度宽度的方法 屏幕分辨率12window.screen.heightwindow.screen.width 浏览器的屏幕的可用宽度（不包括任务栏）12window.screen.availWidthwindow.screen.availHeight 网页可见区域12document.body.clientWidthdocument.body.clientHeight 网页可见区域宽高（加边线）12document.body.offsetWidthdocument.body.offsetHeight 网页正文全文宽高12document.body.scrollWidthdocument.body.scrollHeight 当前页面滚动条横纵坐标值纵坐标（横坐标也一样，只是将scrollTop换成scrollLeft,window.pageYOffset换成window.pageXOffset）12345678document.documentElement.scrollTop //页面具有 DTD，或者说指定了 DOCTYPE 时window.pageYOffset //低版本IE浏览器不支持 document.body.scrollTop //页面不具有 DTD，或者说没有指定了 DOCTYPEvar scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; //保险办法 获取元素的宽高1234document.getElementsByClassName(&apos;XXX&apos;)[0].offsetWidthdocument.getElementsByClassName(&apos;XXX&apos;)[0].offsetHeightdocument.getElementById(&apos;XXX&apos;).offsetWidth;document.getElementById(&apos;XXX&apos;).offsetHeight;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>获取高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS，CSRF了解一下]]></title>
    <url>%2F2018%2F07%2F17%2FXSS%EF%BC%8CCSRF%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[之前做的好多系统，并没有考虑安全问题，最近才有了这个意识，XSS和CSRF是比较常见的攻击方式，今天就主要了解这两种攻击方式，内容参考自浅说 XSS 和 CSRF，Web安全系列——XSS攻击和网络安全-CSRF XSS跨站脚本攻击(Cross Site Script)，这种攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据。这些恶意程序通常是javascript，但也可能是Java，VBScript，ActiveX，Flash甚至是普通的HTML。如果攻击成功，攻击者就可能会获得更高权限，如用户的隐私数据cookie、session等，也可能会将victim重定向到由攻击者控制的网站，在victim的机器上进行一些恶意操作。 XSS 攻击分类XSS攻击可以分为三类，一类是“反射型”，一类是“存储型”，还有一类”DOM Based” 反射型XSS反射型XSS，也叫作非持久型XSS，字面理解，就是仅对当次页面访问有影响，通常要求用户访问一恶意连接，或者要提交一个表单，或者是进入一个被攻击者篡改后的网站。我们将XSS攻击的恶意脚本称为XSS Payload.反射型XSS把XSS的Payload写在URL中，通过浏览器直接“反射”给用户。 存储型XSS存储型XSS，也叫持久型XSS，会把黑客输入的恶意脚本存储在数据库中或者说服务器端，当其他用户浏览包含该恶意脚本的页面时，就会执行该恶意脚本。如将恶意代码注入到一个新闻文本中或者评论中都会使访问该页面的用户执行这段恶意代码 DOM Based基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行 XSS的可能后果 Cookie劫持攻击，Cookie中一般会保存用户的登录凭证，如果被盗取，可能通过Cookie登进用户的账户进行恶意操作 框架钓鱼，利用JS脚本操作网页中的DOM结构和内容，通过JS脚本，生成虚假的页面，欺骗用户执行操作，从而将用户所有的输入发送到攻击者的服务器上 。。。。。 XSS的预防现如今好多浏览器都内置了XSS的措施，如firfox的CSP，IE8内置的XSS Filter等，开发者还可以使用的其他常用防御手段有 HttpOnly防止截取CookieHttpOnly由微软提出，在IE6中实现，如今已逐渐成为标准，浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。，因此可以防止XSS攻击后的Cookie劫持一个Cookie的使用过程如下： Step1: 浏览器向服务器发送请求，这时候没有cookie。 Step2: 服务器返回同时，发送Set-Cookie头，向客户端浏览器写入Cookie。 Step3: 在该Cookie到期前，浏览器访问该域名下所有的页面，都将发送该Cookie。而HttpOnly是在Set-Cookie时标记的。 输入检查不相信用户的任何输入，对于用户的输入一律进行检查，过滤和转义，建立可信任的字符和HTML标签白名单，对于不再白名单之列的自负或者标签进行过滤或编码 输出转义在服务器端输出数据之前对潜在的威胁的字符进行编码、转义 CSRF跨站请求伪造(Cross-site request forgery)，也叫作one-click attack 或者 session riding，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。通常的CSRF攻击是攻击者借助受害者的Cookie骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下操作可能情况： 用户已经登录了www.aaa.com，自然aaa这个网站就会将用户的登录状态session存在cookie中；然后，aaa.com这个网页有一个对作品点赞的功能，点赞提交地址为aaa.com/api.like?id=777；这时，另外一个叫www.bbb.com的网站，放了这样一个元素，这样的话，一旦用户进入这个bbb.com页面，就会请求aaa.com这个网站的点赞接口，而且点赞的用户对象是888；最后因为用户的登录信息尚未过期，那就等于给id为888这个作品点赞了，然而，用户并不知情。CSRF的预防 Referer Check通过HTTP的referer可知道，用户是通过哪个网站发送这个请求的。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，所以可以通过判断referer的值来防御CRSF攻击，但是referer的判断并不是好方法，有各种方式可以绕过的方法 添加 token 验证CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求CSRF和XSS的对比XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生javascript实现简易计算器]]></title>
    <url>%2F2018%2F06%2F19%2F%E7%94%A8%E5%8E%9F%E7%94%9Fjavascript%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[昨天在公众号上看到一个前端实现计算器的自测题，大概想了下，好像并不能立刻写出来，可能我的编程能力离达标还有很远的距离【手动哭泣】，除了努力学习好像也没有别的办法了，受了打击今天就来实现一下。参考资料：尐轩web前端网络日志首先放一张结果图： HTML部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;calculator&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./layout.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cal-con&quot;&gt; &lt;div class=&quot;result-con&quot;&gt; &lt;p class=&quot;show-con&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;keybord-box&quot;&gt; &lt;div class=&quot;cell-row&quot;&gt; &lt;button class=&quot;cell-item special&quot;&gt;(&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;)&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;AC&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;CE&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;cell-row&quot;&gt; &lt;button class=&quot;cell-item&quot;&gt;7&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;8&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;9&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;x&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;cell-row&quot;&gt; &lt;button class=&quot;cell-item&quot;&gt;4&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;5&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;6&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;cell-row&quot;&gt; &lt;button class=&quot;cell-item&quot;&gt;1&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;2&lt;/button&gt; &lt;button class=&quot;cell-item&quot;&gt;3&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;cell-row&quot;&gt; &lt;button class=&quot;cell-item &quot;&gt;0&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;÷&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;.&lt;/button&gt; &lt;button class=&quot;cell-item special&quot;&gt;=&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src=&quot;./calculator.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869*&#123; margin: 0; padding: 0;&#125;body&#123; background: #ccc;&#125;.cal-con&#123; width: 320px; height:550px; margin: 0 auto; box-shadow: 2px 4px 8px rgba(0,0,0,.5); background: #3b3131; overflow: hidden;&#125;.cal-con .result-con&#123; position: relative; width: 320px; height: 120px; &#125;.cal-con .result-con .show-con&#123; position: absolute; top: 50%; margin-top: -30px; width: 280px; text-align: center; word-break: break-all; color: #fff; font-size: 18px; font-weight: bold; padding: 10px 20px; &#125;.cal-con .keybord-box&#123; width:320px; margin: 0 auto; border-top: 1px solid #636060;&#125;.cal-con .keybord-box .cell-row&#123; margin: 15px 0;&#125;.cal-con .keybord-box .cell-row .cell-item&#123; width: 60px; height:60px; margin: 0 5px 0 10px; border-radius: 100px; outline: none; border: none; box-shadow: 2px 4px 8px rgba(0,0,0,.5); background: #8b7d7d; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer;&#125;.cal-con .keybord-box .cell-row .cell-item.other&#123; width: 135px; margin:0 10px;&#125;.cal-con .keybord-box .cell-row .cell-item.special&#123; /* background: #e9a610; */ background: linear-gradient(to bottom, rgba(252,156,23,1) 0%, rgba(247,126,27,1) 100%);&#125;/* 选中按钮 */.cal-con .keybord-box .cell-row .cell-item:active&#123; box-shadow: 0 0 5px 5px dodgerblue;&#125; JS部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//获得输入的键值var keys = document.getElementsByClassName(&quot;keybord-box&quot;)[0];//显示器内容var show = document.getElementsByClassName(&quot;show-con&quot;)[0], countNum = 0,//记录显示屏上字符个数 isDecimal = false; //判断显示屏上数字是否已有小数点keys.onclick = function(e)&#123; e=e||window.event; //兼容IE var target = e.target||e.srcElement; if(target.nodeName.toLowerCase() === &apos;button&apos;)&#123; var btnType = target.innerText; if(show.innerText == &apos;Math Error&apos; &amp;&amp; btnType != &apos;AC&apos;)&#123; return; &#125; //button为AC，即all clear，清零 if(btnType == &apos;AC&apos;)&#123; isDecimal = false; show.innerText = &apos;0&apos;; countNum = 1; &#125;//清除当前输入的最后一位 else if(btnType == &apos;CE&apos;)&#123; if(show.innerText != &apos;0&apos;)&#123; if(show.innerText.length === 1)&#123; show.innerText = &apos;0&apos;; &#125;else &#123; show.innerText = show.innerText.slice(0,-1); &#125; countNum--; &#125; &#125;else if(btnType == &apos;=&apos;)&#123; if(!show.innerText)&#123; return; &#125;else&#123; show.innerText = show.innerText.replace(/x/g,&apos;*&apos;); show.innerText = show.innerText.replace(/÷/g,&apos;/&apos;); var result; try&#123; result = eval(show.innerText) + &apos;&apos;; if(result.search(/\./) &gt; 0)&#123; isDecimal = true; if(result.split(&apos;.&apos;)[1].length &gt; 5)&#123; //精确到小数点后五位 result = result.toFixed(5); &#125; &#125; show.innerText = result; countNum = result.length; &#125;catch(e)&#123; show.innerText = &apos;Math Error&apos;; &#125; &#125; &#125;else &#123; //如果不是数字，且点击键值非&apos;.&apos; if(isNaN(+btnType) &amp;&amp; btnType != &apos;.&apos;)&#123; isDecimal = false; &#125; if(btnType == &apos;.&apos;)&#123; if(isDecimal)&#123; return; &#125; isDecimal = true; &#125; if(show.innerText == &apos;0&apos; &amp;&amp; (!isNaN(+btnType) || btnType == &apos;(&apos; || btnType == &apos;)&apos; ))&#123; show.innerText = &apos;&apos;; &#125; show.innerText += btnType; if(countNum++ &gt;= 44)&#123; alert(&apos;输入字符过多&apos;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>简易计算器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL内部搜索引擎]]></title>
    <url>%2F2018%2F05%2F29%2FMySQL%E5%86%85%E9%83%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[什么是存储引擎关系数据表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时很差；而在我们实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，数据的处理上也会存在着差异。对于MySQL来说，它提供了很多种类型的存储引擎，我们可以根据对数据处理的需求，选择不同的存储引擎，从而最大限度的利用MySQL强大的功能。mysql5.5以后，默认使用InnoDB搜索引擎 若要修改默认引擎，可以修改配置文件中的default-storage-engine。可以通过show variables like ‘default_storage_engine’,查看当前数据库的默认引擎。命令：show engines和show variables like ‘have%’可以列出当前数据库支持的引擎，其中value显示为disabled的记录表示数据库支持此引擎，而在数据库启动时被禁用。在MySQL5.1以后，information_chema数据库中存在一个engines的表，它提供的信息与show engines语句完全一样，可以使用下面语句来查询存储引擎支持哪些事务处理：select engine from information_chema.engines where transactions=’yes’可以通过engine关键字在创建或修改数据库时指定所使用到的引擎在创建表的时候通过engine=…或type=…来指定所使用到的引擎。show table status from DBname来查看指定表到引擎主要搜索引擎：MyISAM,InnoDB,MEMORY和MERGE MyISAM：MyISAM是独立于操作系统的，这说明可以轻松地将其从windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名，例如建立一个MyISAM引擎的tb_Demo表，就会生成以下三个文件： 文件名 意义 tb_demo.frm 存储表定义 tb_demo.MYD 存储数据 tb_demo.MYI 存储索引 不适用场景：MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。适用场景： 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是他最突出的优点 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或者web服务器日志数据。InnoDBInnoDB是一个健壮的事务性存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。InnoDB 还引入了行级锁定和外键约束，在以下场合中使用InnoDB是最理想的选择。 更新密集的表，他特别适合处理多重并发的更新请求 事务，innoDB存储引擎是支持事务的标准mySQL存储引擎 自动灾难恢复，与其他存储引擎不同，innodb能自动从灾难中恢复 外键约束，mysql支持外键的存储引擎只有innoDB 支持自动增加列AUTO_INCREMENT属性一般来说，如果需要事务支持，并且有较高的并发读取效率，InnoDB是不错的选择。MEMORY使用 MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提高很高的性能，但当mysqld守护进程崩溃时，所有memory数据都会丢失。获得速度的同时也会带来一些缺陷。他要求存储在memory数据表里的数据使用的长度不变的格式，这意外着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当作长度固定不变的CHAR类型，所以可以使用。一般在以下几种情况使用Memory存储引擎： 目标数据较小，而且被频繁的访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小； 如果数据是临时的，而且要求立即可用，就可以存放在内存表中 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响 Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中 MERGEMERGE 存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，尽管其使用不如其他引擎突出，但是某些情况下非常有用，说白了，merge表就是几个相同MyISAM表的聚合器Merge表中并没有数据，对merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。Merge存储引擎的使用场景对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间段相关。例如，可以用12个相同的表来存储服务器日志数据，每个表对应各个月份的名字来命名，当有必要基于所有12个日志表的数据生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除merge表知识删除merge表的定义，对内部的表没有任何影响ARCHIVE Archive+是归档的意思，在归档之后很多高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。MySQL5.5版以前，Archive是不支持索引，但是在MySQL5.5以后的版本中就开始支持索引了Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。 如何使用合适的存储引擎？ 是否需要支持事务 是否需要使用热备 崩溃恢复：能否接受崩溃 是否需要外键支持]]></content>
      <categories>
        <category>mysql,数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>内部搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码体制（加密算法）]]></title>
    <url>%2F2018%2F05%2F29%2F%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[密码体制分类方法有三种：根据密码算法所用的密钥数量一般分为两类：非对称密码体制，对称密码体制根据对明文信息的处理方式可将对称密码体制分为分组密码（DES、AES、IDEA、RC6）和序列密码（RC4、A5、SEAL）根据是否能进行可逆的加密变换可以分为单项函数密码体制（MD4、MD5、SHA-1）和双向变换密码体制 对称密码体制定义对一个提供保密服务的密码系统，他的加密密钥和解密密钥相同，或者虽然不相同，但是其中一个的任意一个可以很容易的导出另外一个，那么这个系统采用的就是对称密钥体制 特点优点： 加解密速度快 效率高 算法安全性高缺点： 密钥分发过程复杂，所花代价大 密钥管理量困难(实现n个用户两两保密通信，每个用户需要安全获取并保管(n-1)个密钥) 保通信系统开放性差 存在数字签名的困难性(通信双方拥有相同的秘密信息，接收方可以伪造数字签名，发送方可以抵赖)经典算法DES、AES、IDEA、RC6 非对称密码体制定义对一个提供保密服务的密码系统，他的加密算法和解密算法分别用不同的密钥实现，并且加密密钥不能推导出解密密钥，那么这个系统采用的就是非对称密钥体制。 特点每一个用户有一对密钥，用公钥加密，私钥解密优点： 密钥分配简单 密钥量少，容易管理 系统开放性好 可以实现数字签名缺点： 加密、解密运算复杂 处理速度较慢 同等安全强度下，非对称密码体制密钥位数较多 由于加密密钥公开，存在“可能报文攻击”威胁，这个可以通过引入随机化因子，使相同明文加密的密文不同 单项函数密码体制它是一种特殊的密码体制，可以很容易将明文转换成密文。但是密文再转换成明文却是不可行的，有时甚至是不可能的，简单来说就是不可逆的，所以叫单向，它只适合于某些特殊的不需要解密的应用场合，如用户口令的存储和信息的完整性保护与鉴别等因为做系统时用web页面用户登录经常会用到MD5和SAH-1，所以这里对两种算法做简单介绍 SHA-1算法过程原理原理 SHA-1是一种数据加密算法，该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。 单向散列函数的安全性在于其产生散列值的操作过程具有较强的单向性。如果在输入序列中嵌入密码，那么任何人在不知道密码的情况下都不能产生正确的散列值，从而保证了其安全性。ＳＨＡ将输入流按照每块５１２位（６４个字节）进行分块，并产生２０个字节的被称为信息认证代码或信息摘要的输出。 该算法输入报文的最大长度不超过2^64位，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。 通过散列算法可实现数字签名实现，数字签名的原理是将要传送的明文通过一种函数运算（Hash）转换成报文摘要（不同的明文对应不同的报文摘要），报文摘要加密后与明文一起传送给接受方，接受方将接受的明文产生新的报文摘要与发送方的发来报文摘要解密比较，比较结果一致表示明文未被改动，如果不一致表示明文已被篡改。 MD5(Message Digest Algorithm 消息摘要算法第五版)是计算机安全领域广泛使用的一众散列函数，用一提供消息的完整性保护。MD5即信息摘要算法5，用于确保信息传输完整一致，将数据转换为另一个固定长度值，它的特点： 压缩性：不限定输入长度，输出的MD5值长度都是固定的 容易计算：从原数据计算出MD5值很容易 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的 两种加密算法的作用用于计算出一段不可逆向计算的数值，以此来验证该文件是否被修改的. 它可以帮你验证从网上下载下来的windows7安装程序是否与发布人发布的东西完全一致，也就是帮助你验证这个程序有没有经过他人（非发布人）的修改。 二者的区别 因为SHA-1生成的是160位的报文摘要，而MD5生成的是128位的报文摘要，所所以暴力破解使用强性技术产生任何一个保温使其摘要等于所给的报文摘要MD5是2^128数量级的操作，而SHA-1是2^160数量级的操作，SHA-1对强行攻击有更大强度 由于SHA-1 的循环步骤比MD5多（80:64）且要处理的缓存大（160 比特:128比特）相同硬件上，SHA-1运行速度慢于MD5]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组常用方法]]></title>
    <url>%2F2018%2F05%2F29%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于前端er来说，javaScript中的数组一定是避不开的，但是数组操作还挺多的，有的还很像，你真的清楚每个方法需要的参数和返回值吗，反正我经常搞混，今天就来整理一下常用的数组处理方法 ，参考廖雪峰 创建数组1.使用Array构造函数12345var arr = new Array();var arr = new Array(20);//预先知道数组要保存的项目数量 var arr = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//也可直接向构造的函数中传递数组中包含的项var arr = Array(3); //省略“new”,创建一个包含3项的数组var arr = Array(“Greg”); 2.使用数组字面量表示法12var arr = [1, 2, 3]；var arr = []; //创建空数组 获取数组值，使用方括号加数字索引的方法12var arr = [1, 2, 3];console.log(arr[0]); // 1 获取array长度，直接访问length属性12var arr = [1, 2, 3];console.log(arr.length); // 3 检测数组确定某个对象是不是数组 1.使用instanceof12if(value instanceof Array)&#123;&#125; 使用instanceof的前提是，假定只有一个全局执行环境。在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回false，因为 Array.prototype !== window.frames[0].Array.prototype（这一段是看书没有看懂，查资料看到的，其实不是很理解，总之如果你也不理解，暂时可以理解为当存在多个全局执行环境时instanceof检测数组会出问题） 2.Array.isArray()方法为了避免上面的问题，ECMAScript5新增了Array.isArray()方法，这个方法的目的是最终确定这个值到底是不是数组，而不管他是在哪个全局执行环境创建的 1if(Array.isArray(value))&#123;&#125; 支持此方法的浏览器：IE9+，Firefox 4+，Safari5+、Opera 10.5+和Chrome 转换方法1. toString()把数组转化为字符串，并返回结果，每一项以逗号分割。结果唯一 2. toLocaleString()把数组根据你机器的本地环境转换为为字符串，并返回结果,常用语返回时间类型数据，结果会因本地环境不同而有所不同 3. valueOf()返回数组本身1234var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);console.log(arr.valueOf()); //(5)[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]console.log(arr.toString()); //1,2,3,4,5console.log(arr.toLocaleString());//1,2,3,4,5 栈方法1.push()可向数组的末尾添加一个或多个元素，并返回新的长度，数组本身会发生变化语法array.push(item1, item2, …, itemX)参数 可添加多个参数，至少有一个返回值 数组新长度 123var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;); console.log(arr.push(&quot;6&quot;)); // 6 console.log(arr); // [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;] 2.pop()删除数组的最后一个元素并返回删除的元素，此方法会改变数组的长度语法 array.pop()返回值 被删除的最后一个元素 123var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;); console.log(arr.pop()); // 5 console.log(arr); // [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;] 队列方法1.shift()把数组的第一个元素从其中删除，并返回第一个元素的值,有点像pop()，此方法会改变数组的长度语法array.shift()返回值 被删除的第一个元素的值 123var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;); console.log(arr.shift()); // 1 console.log(arr); // [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] 2.unshift()可向数组的开头添加一个或更多元素，并返回新的长度,有点像push()语法array.unshift(item1, item2, …, itemX) 参数 可添加多个参数，至少有一个返回值 数组新长度 123var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;); console.log(arr.unshift(&quot;6&quot;)); // 6 console.log(arr); // [&quot;6&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] 重排序方法1.reverse()颠倒数组中元素的顺序语法array.reverse()返回值 颠倒顺序后的数组12var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;); console.log(arr.reverse()); // [&quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;] 2.sort()对数组的元素进行排序语法array.sort(sortby)参数 可选。规定排序顺序。必须是函数。返回值 排序后的新数组 123456789101112131415 var arr = new Array(&quot;3&quot;,&quot;19&quot;,&quot;5&quot;,&quot;1&quot;,&quot;2&quot;); var array = [&quot;George&quot;,&quot;John&quot;,&quot;Thomas&quot;,&quot;James&quot;,&quot;Adrew&quot;,&quot;Martin&quot;] function sortSec(a,b)&#123; return a - b; &#125; console.log(arr.sort()); //[&quot;1&quot;, &quot;19&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;] console.log(arr.sort(sortSec)); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;19&quot;] console.log(array.sort()); //[&quot;Adrew&quot;, &quot;George&quot;, &quot;James&quot;, &quot;John&quot;, &quot;Martin&quot;, &quot;Thomas&quot;]``` ### 操作方法 #### 1.concat()连接两个或多个数组,该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本**语法**array.concat(arrayX,arrayX,......,arrayX) **参数** 必需,该参数可以是具体的值，也可以是数组对象,可以是任意多个。 **返回值** 返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 array 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组 var arr = new Array(“3”,”19”,”5”,”1”,”2”); var array = [“George”,”John”,”Thomas”,”James”,”Adrew”,”Martin”] console.log(arr.concat(array));// [“3”, “19”, “5”, “1”, “2”, “George”, “John”, “Thomas”, “James”, “Adrew”, “Martin”]1234567891011#### 2.slice()从已有的数组中返回选定的元素,是当前数组的子数组**语法**array.slice(start,end)**参数** 参数 | 描述---|---start | 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推end | 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素**返回值** 返回一个新的数组，包含从 start 到 end （不包括该元素）的 array 中的元素。 var arr = new Array(“3”,”19”,”5”,”1”,”2”); console.log(arr.slice(1));//[“19”, “5”, “1”, “2”] console.log(arr.slice(1,-1));//[“19”, “5”, “1”] console.log(arr.slice(1,4)); //[“19”, “5”, “1”]123456789101112#### 3.splice()从数组中添加/删除项目，然后返回被删除的项目,该方法会改变原始数组**语法**array.splice(index,howmany,item1,.....,itemX)**参数** 参数 | 描述---|---index| 必需，整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置howmany | 必需。要删除的项目数量。如果设置为 0，则不会删除项目如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。item1, ..., itemX | 可选。向数组添加的新项目。**返回值** 如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组 var arr = new Array(“0”,”1”,”2”,”3”,”4”,”5”); console.log(arr.splice(0,2));//[“0”, “1”] console.log(arr); //[“2”, “3”, “4”, “5”]12 var arr = new Array(“0”,”1”,”2”,”3”,”4”,”5”); console.log(arr.splice(1));//[“1”, “2”, “3”, “4”, “5”] console.log(arr);//[“0”]12 var arr = new Array(“0”,”1”,”2”,”3”,”4”,”5”); console.log(arr.splice(2,0,”6”,”6”,”6”));//[]空数组 console.log(arr);//[“0”, “1”, “6”, “6”, “6”, “2”, “3”, “4”, “5”]1234567891011### 位置方法 #### 1.indexOf()返回某个指定的字符串值在数组中首次出现的位置，从数组的开头(位置0)开始向后找**语法**aarray.indexOf(item,start)**参数** 参数 | 描述---|---item | 必须。查找的元素start | 可选的整数参数，规定在数组中开始检索的位置。它的合法取值是 0 到 array.length - 1。如省略该参数，则将从字符串的首字符开始检索**返回值** 元素在数组中的位置,如果没有搜索到则返回 -1 var arr = new Array(“0”,”1”,”2”,”3”,”4”,”5”); console.log(arr.indexOf(“5”)); //5 console.log(arr.indexOf(“5”,1)); //5 console.log(arr.indexOf(“6”)); //-1 123456789#### 2.lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索**语法**array.lastIndexOf(item,start)**参数** 参数 | 描述---|---item | 必须。查找的元素start | 可选的整数参数，规定在数组中开始检索的位置。它的合法取值是 0 到 array.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索**返回值** 返回的是出现的最后一个 searchvalue 的位置 var arr = new Array(“0”,”1”,”2”,”5”,”3”,”4”,”5”); console.log(arr.lastIndexOf(“5”)); //6 console.log(arr.lastIndexOf(“5”,4)); //3```]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$(document).ready（）与window.onload的区别]]></title>
    <url>%2F2018%2F05%2F19%2F%24(document).ready()%E4%B8%8Ewindow.onload%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[功能区别因为javaScript脚本往往需要在文档加载完成后才能执行，否则可能会出现无法获取对象的情况，为了避免这样的情况，可以将脚本文件放在页面底部，或者使用window.onload。而$(document).ready（）与window.onload功能相似，有一些区别： 执行时间有区别window.onload必须等到所有资源加载完成后，才可以执行而$(document).ready在DOM树加载完后就可以执行，因此速度要快一些 允许存在的个数不同window.onload不能写多个，因为即使写了多个也只会执行一个$(document).ready()可同时编写多个，并且都可以得到执行 是否有简化写法window.onload没有简化写法$(document).ready(function(){})可以简写成$(function(){}); 用法1window.onload = function()&#123;....&#125; 1$(document).ready(function()&#123;...&#125; ```$(function(){…});]]></content>
      <categories>
        <category>javaScript,jQuery</category>
      </categories>
      <tags>
        <tag>文档加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期转换的那些事儿]]></title>
    <url>%2F2018%2F05%2F15%2F%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[JavaScript中日期转换日期字符串转时间戳获取当前时间戳，使用new Date() 1234var timestamps = new Date(); //Mon May 14 2018 22:17:38 GMT+0800 (中国标准时间)timestamps.getFullYear() //2018 获取年timestamps.getMonth() +1 // 5 获取月份 此处需要+1，因为js中从0开始算月，0就是1月，1就是2月timestamps.getDate() // 14 获取日 如果想将当前时间转换成字符串，可以使用两个函数 toLocaleString() //获取的是本地时间字符串，但是因为月份日期“0”不显示，位数不固定，需要截取的话，只获取年月日，可以用正则，而且不同浏览器下转换格式不同 1timestamps.toLocaleString() //2018/5/14 下午10:23:46（chrome） toISOString() //返回格林尼治标准时间，比北京时间晚八小时，位数固定，如果只需要前面年月日部分，可以截取部分字符串 12timestamps.toISOString() //2018-05-14T14:20:24.230Zctimestamps.toISOString().slice(0,10) //2018-05-14 时间戳转日期字符串不常用，目前没用过 12345var timestamp3 = 1526265613; var newDate = new Date(); newDate.setTime(timestamp3 * 1000); console.log(newDate.toLocaleDateString()); // 2018/5/14 console.log(newDate.toLocaleString()); // 2018/5/14 上午10:40:13 PHP中日期转换时间戳转换为日期可使用date函数直接获得当前时间的时间戳date(format,timestamp)format –必需，规定时间戳的格式timestamp –可选，规定时间戳，默认是当前时间和日期使用方式： date(“Y-m-d H:i:s”) //年月日时分秒一起显示 date(“Y-m-d “, time()) //只显示年月日日期转换成时间戳(unix时间戳)使用strtotime()函数实现使用方式： strtotime(“10:38pm April 15 2015”) //1429137480常用方式 1234&lt;?php$d=strtotime(&quot;10:38pm April 15 2015&quot;);echo &quot;创建日期是 &quot; . date(&quot;Y-m-d h:i:sa&quot;, $d); //2015-04-15 10:38:00?&gt; 还可使用strtotime函数获得以现在为基准的特定时间，例如 12345678910&lt;?php$d=strtotime(&quot;tomorrow&quot;); //明天echo date(&quot;Y-m-d h:i:s&quot;, $d) . &quot;&lt;br&gt;&quot;;$d=strtotime(&quot;next Saturday&quot;); //下个星期六echo date(&quot;Y-m-d h:i:s&quot;, $d) . &quot;&lt;br&gt;&quot;;$d=strtotime(&quot;+3 Months&quot;); //后面三个月echo date(&quot;Y-m-d h:i:s&quot;, $d) . &quot;&lt;br&gt;&quot;;?&gt;]]></content>
      <categories>
        <category>javaScript,php</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>PHP</tag>
        <tag>日期转换</tag>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在客户端上传shell脚本文件，并利用PHP调用执行脚本]]></title>
    <url>%2F2018%2F05%2F07%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0shell%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E5%88%A9%E7%94%A8PHP%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目中的上传包含两部分，一部分是上传文件，一部分是利用PHP执行脚本 上传文件到指定文件夹所谓文件上传是指将本地文本文件，图片视频或者音频等文件上传到服务器上，以供后续操作的过程。上传文件有几种方式，包括： 单纯的form表单上传提交使用form表单的input[type=”file”]控件，打开系统的文件对话选择框，选择文件然后利用submit和form中跳转的action设置实现上传。优点：多浏览器兼容，简单缺点：PHP会限制浏览器上传文件的大小，而且form表单提交后会刷新页面，用户体验不好【注意】 input中type要设置成type=”file”； 设置form中method=”post”； form中enctype中有三种取值 如果是文件上传，需要将enctype=”multipart/form-data” 如果上传文件较大，需要配置php.ini文件（以上传500M以下大小的文件为例）查找以下选项并修改-&gt;file_uploads = On ;打开文件上传选项upload_max_filesize = 500M ;上传文件上限 如果要上传比较大的文件，仅仅以上两条还不够，必须把服务器缓存上限调大，把脚本最大执行时间变长post_max_size = 500M ;post上限max_execution_time = 1800 ; Maximum execution time of each script, in seconds脚本最大执行时间max_input_time = 1800 ; Maximum amount of time each script may spend parsing request datamemory_limit = 128M ; Maximum amount of memory a script may consume (128MB)内存上限 上代码： 12345&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 效果如图：原始的样子不太好看，为了美观大家可以使用label调整样式，例如 1234567891011121314151617181920212223242526css部分.btn &#123; display: inline-block; margin-bottom: 0; user-select: none;&#125;.btn-info &#123; padding:8px; color: #ffffff; background-color: #40bbea; border-color: #29b3e7;&#125;html部分 &lt;div&gt; &lt;label for=&quot;fileName1&quot; &gt;文件上传：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;fileName1&quot; id=&quot;fileName1&quot; style=&quot;height: 32px;width: 300px;&quot; /&gt; &lt;label class=&quot;btn btn-info&quot; for=&quot;updateFile&quot; style=&quot;margin-bottom: 3px;&quot;&gt;浏览&lt;/label&gt; &lt;label class=&quot;btn btn-info&quot; style=&quot;margin-bottom: 3px;&quot; for=&quot;submit&quot; &gt;上传&lt;/label&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;form id= &quot;uploadForm&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;updateFile&quot; name=&quot;file&quot; style=&quot;position:absolute;clip:rect(0 0 0 0);&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;submit&quot; hidden=&quot;hidden&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; 修改后样式如图： -html5的formdata、fileReader利用FormData模拟表单数据，然后通过ajax提交，用FileReader的readAsDataURL方法拿到base64地址来预览。 html部分1234567891011&lt;div id= &quot;uploadForm&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;fileName&quot; style=&quot;height: 32px;width: 300px;&quot; /&gt; &lt;label class=&quot;btn btn-info&quot; for=&quot;file&quot; style=&quot;margin-bottom: 3px;&quot;&gt; &lt;span&gt;浏览&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;btn btn-info&quot; style=&quot;margin-bottom: 3px;&quot; for=&quot;submit&quot;&gt; &lt;span&gt;上传&lt;/span&gt; &lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot; onchange=&quot;showPreview(this)&quot; style=&quot;position:absolute;clip:rect(0 0 0 0);&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;submit&quot; onclick=&quot;doUpload()&quot; hidden=&quot;hidden&quot;&gt;&lt;/div&gt; JavaScript部分 12345678910111213141516171819202122232425function showPreview(source) &#123; var arrs = $(source).val().split(&apos;\\&apos;); var filename=arrs[arrs.length-1]; $(&quot;#fileName&quot;).val(filename); &#125;function doUpload() &#123; var formData = new FormData($( &quot;#uploadForm&quot; )[0]); // 要求使用的html对象 $.ajax(&#123; url: &apos;upload_file.php&apos; , type: &apos;POST&apos;, data: formData, async: true, // 下面三个参数要指定，如果不指定，会报一个JQuery的错误 cache: false, contentType: false, //不要设置Content-Type请求头，因为文件数据是以 multipart/form-data 来编码 processData: false,//不处理数据 success: function (returndata) &#123; /*result = JSON.parse(returndata);*/ alert(returndata); &#125;, error: function (returndata) &#123; alert(returndata); &#125; &#125;);&#125; 需要注意的部分：使用jQuery提供的ajax方法来发送二进制文件，还需要附加两个参数： processData: false // 不要对data参数进行序列化处理，默认为truecontentType: false // 不要设置Content-Type请求头，因为文件数据是以 multipart/form-data 来编码upload_file.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php$url=realpath(dirname(__FILE__).&apos;/../../&apos;); //从当前位置退回到www文件夹目录，这一块儿可根据自己文件所在位置做修改if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)&#123; switch($_FILES[&quot;file&quot;][&quot;error&quot;]) &#123; case 1: echo &quot;上传文件的大小超出了约定值&quot;; break; case 2: echo &quot;上传文件太大 &quot;; break; case 3: echo &quot;文件只被部分上传&quot;; break; case 4: echo &quot;没有上传任何文件&quot;; break; case 6: echo &quot;未指定临时目录&quot;; break; case 7: echo &quot;文件写入磁盘失败&quot; ; break; &#125; &#125;else&#123; $storePath = $url. &quot;/upload&quot; ; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (!file_exists($storePath)) &#123; mkdir($storePath); &#125; else if (file_exists($storePath.&apos;/&apos;.$fileName)) &#123; echo $fileName . &quot; 文件已经存在,如需更新，请点击下方&apos;更新系统&apos;按钮&quot;; &#125; else &#123; //如果 upload 目录不存在该文件则将文件上传到 upload 目录下 //判断文件上传是否采用的POST方式 if(is_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;])) &#123; if(move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$storePath.&apos;/&apos;.$fileName)) &#123; chmod($storePath.&apos;/&apos;.$fileName,0755);// echo &quot;更新文件存储成功,如需更新，请点击下方&apos;更新系统&apos;按钮&quot;; &#125;else&#123; echo &apos;更新文件存储失败&apos;; &#125; &#125;else&#123; echo &apos;没有可存储的更新文件&apos;; &#125; &#125; &#125;?&gt; 关于PHP上传文件通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。 第一个参数是表单的 input name，第二个下标可以是 “name”, “type”, “size”, “tmp_name” 或 “error”。就像这样： $_FILES[“file”][“name”] - 被上传文件的名称$_FILES[“file”][“type”] - 被上传文件的类型$_FILES[“file”][“size”] - 被上传文件的大小，以字节计$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称$_FILES[“file”][“error”] - 由文件上传导致的错误代码这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关什么用户有权上传文件的限制，例如上传格式和大小。 保存上传的文件到指定文件夹使用move_uploaded_file($_FILES[‘file’][‘tmp_name’],$storePath.’/‘.$fileName)move_uploaded_file(file,newloc)，两个参数都是必需项，前者指需要保存的文件，后者是你设置的新的保存路径chmod($storePath.’/‘.$fileName,0755)；这个是为了修改上传文件的权限，因为上传文件的权限默认是644，所以如果有执行该文件的需求则需要自己手动修改权限；而标题的第二部分是利用php执行linux命令,shell脚本函数 PHP执行外部命令的几个函数 exec()string exec ( string command [, array &amp;output [, int &amp;return_var]] )说明：前面是要执行的命令,但是exec执行系统外部命令时不会输出结果，而是返回结果的最后一行。如果想得到结果，可以使用第二个参数，让其输出到指定的数组。此数组一个记录代表输出的一行。即如果输出结果有20行，则这个数组就有20条记录，所以如果需要反复输出调用不同系统外部命令的结果，最好在输出每一条系统外部命令结果时清空这个数组unset($output)，以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回0 shell_exec()string shell_exec ( string $cmd )直接执行命令$cm，输出命令执行结果，如果执行过程中发生错误或者进程不产生输出，则返回 NULL，所以，使用本函数无法通过返回值检测进程是否成功执行。 system()string system ( string $command [, int &amp;$return_var ] )说明：system和exec的区别在于，system在执行系统外部命令时，它执行给定的命令，输出和返回结果。第二个参数是可选的，用来得到命令执行后的状态码。状态码介绍如果返回0是运行成功，在Bash中，当错误发生在致命信号时，bash会返回128+signal number做为返回值。如果找不到命令，将会返回127。如果命令找到了，但该命令是不可执行的，将返回126。除此以外，Bash本身会返回最後一个指令的返回值。若是执行中发生错误，将会返回一个非零的值。Fatal Signal : 128 + signoCan’t not find command : 127Can’t not execute : 126Shell script successfully executed : return the last command exit statusFatal during execution : return non-zero passthru()void passthru ( string $command [, int &amp;$return_var ] )说明: passthru与system的区别，passthru直接将结果输出到浏览器，不返回任何值，且其可以输出二进制，比如图像数据。第二个参数可选，是状态码。当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>上传文件</tag>
        <tag>PHP</tag>
        <tag>formdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局，双飞翼布局]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[解决的问题圣杯和双飞翼布局解决的问题一样，都是：左右栏固定，中间自适应的三栏布局。 实现方式共同点两者实现方法前面的思路都是一样的： 中间栏放在前面优先渲染； 中间栏width设为100%； 三栏全部float浮动； 此时的效果因为中间栏设置了100%的宽度，所以是中间栏在上，左右两栏接着中间栏下一行然后紧挨排列，为了使三栏能够同行排列，左右两栏使用负margin值，而两种布局的区别就在于如何使中间栏内容不被遮挡。具体来说，左边列设置margin-left值为-100%，右边列设置margin-left值为负的自身宽度值。 如图所示不同点圣杯布局： 中间部分设置左右padding值来空出地方放置左右两栏 三栏设置position：relative相对定位，然后左列设置left值为负的自身宽度值，右列设置right值为负的自身宽度值存在问题当中间部分宽度小于两边的时候，通过padding,left,right值没有办法来控制三栏的平衡，所以这种情况布局会乱掉。解决办法整个容器设置min-width（eg min-width: 700px）效果图代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style&gt; .container&#123; margin: 0; padding: 0; background: #ccc; min-width: 700px; &#125; header,footer&#123; box-sizing: :border-box; border: 1px solid #000; background: #c60023; text-align: center; height:20px; line-height: 20px; &#125; .middle,.left,.right&#123; position: relative; float: left; word-wrap: break-word; word-break: break-all; min-height: 400px; &#125; .body&#123; padding: 0 200px; overflow: hidden; text-align: center; height: 400px; line-height: 50px; &#125; .middle&#123; width:100%; background: #00BBFF； &#125; .left&#123; margin-left: -100%; left:-200px; width:200px; background: #33dd33; &#125; .right&#123; margin-left: -200px; right:-200px; width:200px; background: #cc00ff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt;页眉&lt;/header&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;middle&quot;&gt;中间ahahahahahhahahhhahahahahka看看会不会遮住中间的内容我真的好像不是很努力看着那些为梦想努力的孩子觉得自己真的和他们相比差的好多自己不努力然后所以不期待好的结果跑 应该是不敢吧&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边你好怀念好神经跨境电商数据库是尸骨未寒是更深的山洞换手机号噫吁嚱危乎高哉蜀道之难难于上青天残存及预付开国何茫然&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边地方点v与工行卡度越高虎俄日合格分开译韩国译各行业UI高峰会议US复活甲框架&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;页尾&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局： 在中间部分嵌一个子div，设置该div的左右margin，留出左右两栏位置，设置margin-left:左栏宽度，margin-right：右栏宽度 如果还需要设置每部分的padding，则可以相应调节上一步中margin值 效果图代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;双飞翼布局&lt;/title&gt; &lt;style&gt; .container&#123; margin: 0; padding: 0; background: #ccc; min-width: 700px; &#125; header,footer&#123; box-sizing: :border-box; border: 1px solid #000; background: #c60023; text-align: center; &#125; .middle,.left,.right&#123; float: left; min-height: 400px; &#125; .middle&#123; width:100%; &#125; .middle-inner&#123; margin:0 210px; padding:0 10px; word-wrap: break-word; word-break: break-all; background: #00BBFF; min-height: 400px; &#125; .left&#123; margin-left: -100%; padding-left: 10px; width:200px; background: #33dd33; &#125; .right&#123; margin-left: -210px; padding-left: 10px; width:200px; background: #cc00ff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt;页眉&lt;/header&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;middle-inner&quot;&gt;中间ahahahhhahahhahahhhahahahahka看看会不会遮住中间的内容我真的好像不是很努力看着那些为梦想努力的孩子觉得自己真的和他们相比差的好多自己不努力然后所以不期待好的结果跑 应该是不敢吧&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边你好怀念好神经跨境电商数据库是尸骨未寒是更深的山洞换手机号噫吁嚱危乎高哉蜀道之难难于上青天残存及预付开国何茫然&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边地方点v与工行卡度越高虎俄日合格分开译韩国译各行业UI高峰会议US复活甲框架&lt;/div&gt; &lt;footer&gt;页尾&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 JavaScript 中， (a ==1 && a== 2 && a==3) 是否有可能为 true]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%9C%A8-JavaScript-%E4%B8%AD%EF%BC%8C-a-1-a-2-a-3-%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%BA-true%2F</url>
    <content type="text"><![CDATA[这是最近国外一个求职者在面试时被问到的问题，虽然看到这个问题的时候就想到答案是”yes”,因为在 JavaScript 中，两个”==”是松散相等运算符，所以肯定是有一种方法最后使这个式子为true,但是真的自己写又不会了，就从别处学习了一下别人怎么写： 方法一自定义 toString（或者 valueOf）方法，每次调用改变一次返回值，从而满足判断条件12345678910const a = &#123; i: 1, toString: function () &#123; return a.i++; &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&apos;Hello World!&apos;);&#125; 注释：使用“==”时，如果两边类型不同，这个操作符会先转换操作数（强制转型）尝试将其中两边类型转换成相同的然后进行比较，转换不同数据类型，遵循的基本工作： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换成数值–false转为0，true转为1； 如果一个操作数是字符串，另一个是数值，在比较相等性之前先将字符串转换成数值； 如果一个操作数是对象，另一个不是，则调用valueOf()方法，用得到的基本类型值按照前面规则比较 null和undefined是相等的，要比较相等性前，不能将null和undefined转换成其他任何值 如果其中一个操作数是NaN，则相等操作符返回false valueOf和toString比较javascript中所有数据类型都拥有valueOf和toString这两个方法，null除外,toString()函数的作用是用是返回一个反映这个对象的字符串。valueOf()函数的作用是返回它相应的原始值。 方法二123456789101112with(&#123; get a() &#123; return Math.floor(Math.random()*4); &#125;&#125;)&#123; for(var i=0;i&lt;1000;i++)&#123; if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(&quot;after &quot;+(i+1)+&quot; trials, it becomes true finally!!!&quot;); break; &#125; &#125;&#125; 这个都没看懂【大哭】，先Mark一下 方法三123456789var val = 0;Object.defineProperty(window, &apos;a&apos;, &#123; get: function() &#123; return ++val; &#125;&#125;);if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123; console.log(&apos;yay&apos;);&#125; 使用get让 a 的返回值为三个不同的值。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传本地项目到github远程仓库]]></title>
    <url>%2F2018%2F01%2F22%2F%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[默认条件： 已经安装git 有github账号总体流程 进入到自己项目所在文件夹，默认你已经安装了git ，在文件夹中点击鼠标右键，点击git bash ，打开git命令行； 初始化版本库 1git init 执行该命令后，项目文件夹中会自动创建一个.git文件夹 将项目文件扔到缓存区中 1git add . 用commit推送代码到本地版本库，并填写提交备注 1git commit -m &quot;简单描述&quot; 在github上新建仓库，并将本地项目与远程仓库关联起来新建仓库：1git remote add origin https://自己的仓库url地址 自己仓库地址： 步骤4中容易出现的问题及解决办法添加远程github仓库的时候提示错误：fatal: remote origin already exists.解决方法：删除远程仓库： 1$ git remote rm origin 如果这个命令依旧报错，我们可以手动修改git/config文件内容，使用命令 1$ vi .git/config 删掉[remote “origin”]这一行内容 如何退出vim编辑器按住esc,两次大写Z即可退出然后再来添加远程仓库1git remote add origin https://自己的仓库url地址 将本地项目代码上传github之前，先使用git pull1git pull origin master 此处可能遇到的问题：解决方法： 1git pull origin master --allow-unrelated-histories 然后使用git push 1git push -u origin master 基本的操作到此就结束了]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器操作元素]]></title>
    <url>%2F2017%2F12%2F14%2FjQuery-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1. jquery 操作元素常用的有： 获取内容$(“#test”).text();$(“#test”).html();$(“#test”).val() 获取属性$(“#test”).attr(“href”) 设置或者修改属性$(“#XXX”).attr(“disabled”,”disabled”);$(“#XXX”).removeAttr(“checked”); input 、select在value值变化时可以调用不同的函数 1234567891011121314$(&quot;#xxx&quot;).change(function()&#123; var value = $(this).children(&apos;option:selected&apos;).val(); switch (value) &#123; case &apos;xxx&apos;: XXX； break; case &apos;xxx&apos;: xxx; break; case &apos;xxx&apos;: xxx; break;&#125;&#125;) onclick是绑定事件，click它本身是一种方法，作用是触发onclick事件123$(&quot;#xxx&quot;).click(function()&#123; XXX &#125;) 动态加载select选项，并自定义属性 原生javascript 12345var SelectObj=document.getElementById(&apos;xxx&apos;); SelectObj.options.length=0;//清空selectvar newOption = new Option(文本内容,value值);newOption.setAttribute(&quot;自定义属性名&quot;,属性值);SelectObj.add(newOption); jQuery添加option选型，并增加自定义属性 123$(&quot;#car&quot;).append(&quot;&lt;option value=&apos;Benz&apos; data-count=&apos;3&apos;&gt;Benz&lt;/option&gt;&quot;)//添加选项在后面$(&quot;#car&quot;).prepend(&quot;&lt;option value=&apos;Benz&apos; data-count=&apos;3&apos;&gt;Benz&lt;/option&gt;&quot;)//添加选项在最前面$(&quot;#car&quot;).empty();//清空select jQuery删除option选型 12$(&quot;#car option:last&quot;).remove(); //删除Select中索引值最大Option(最后一个) $(&quot;#car option[index=&apos;0&apos;]&quot;).remove(); //删除Select中索引值为0的Option(第一个) 不需要自定义属性，直接加option选项 原生javaScript 1SelectObj.options.add(new Option(text,value)); jquery 1$(&quot;#car&quot;).append(&quot;&lt;option value=&apos;Benz&apos;&gt;Benz&lt;/option&gt;&quot;); jquery根据value值显示被选中的选项1$(&quot;#add_dept&quot;).find(&quot;option[value = &apos;&quot;+dept_id+&quot;&apos;]&quot;).attr(&quot;selected&quot;,&quot;selected&quot;); jquery获取select 被选中的value值，文本内容，属性值12345var dept_id = $(&apos;#add_dept&apos;).val();//获取value值var dept =$(&quot;#add_dept option:selected&quot;).text();//获取选中的option文本或者也可以是$(&quot;#add_dept&quot;).find(&quot;option:selected&quot;).text();var domain = $(&quot;#add_dept option:selected&quot;).attr(&quot;data-domin&quot;);//获取自定义属性值]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型、原型链]]></title>
    <url>%2F2017%2F12%2F06%2FJavaScript%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在JavaScipt中，万物皆对象 原型模式 是什么在javaScript中，我们创建的每个函数都有一个prototype(原型)属性，换言之，只要创建一个新函数，就会根据一定的规则为函数创建一个prototype属性，叫原型，这个（原型）属性也是一个对象，这个对象又有一个constructor属性，该属性指向是构造函数；例如：123456function sayHi()&#123; this.name = &apos;hello&apos;; this.saySomething = function()&#123; console.log(this.name); &#125;&#125; 在没有设置这个原型属性的时候，这个原型包含两部分(constructor 和proto),1console.log(sayHi.prototype); 结果是： 默认情况下，a.prototype下会带有一个constructor属性，这个属性指向创建当前函数对象的构造函数，在上例中，a.prototype.constructor指向的是sayHi()函数本身 1sayHi.prototype.constructor === sayHi//true 我们可以给继续给原型添加属性和方法，如： 1sayHi.prototype.name = &apos;nihao&apos;; 作用用来实现基于原型的集成和属性的共享 （其实到现在还是没有理解使用圆形的好处，以后在应用中用到应该会理解更深刻） 原型链提到原型链，就不得不说proto，proto是任何对象都会有的属性，JavaScript中万物皆对象，所以会构成一条proto连起来的一条链，递归访问proto必须到头，并且值是nullproto是js内部使用寻找原型链的属性，通过该属性可以允许使用实例对象直接访问原型 123function Person()&#123;&#125;var p = new Person();//以前是不能直接使用p直接访问对象原型，现在有了_proto_后，p._proto_可以直接访问对象原型，p.__proto__ === Person.prototype 当js引擎查找对象属性，先在对象本身属性中查找，如果没有，就沿着原型链向上查找1234567891011121314function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype=&#123; sayHello:function()&#123; console.log(&quot;你好&quot;+&quot;,&quot;+this.name); &#125;&#125;var p =new Person(&quot;尼尔.波兹曼&quot;,19);p.sayHello();console.dir(p);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>prototype</tag>
        <tag>_proto_</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件冒泡]]></title>
    <url>%2F2017%2F11%2F16%2F%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[要想了解jQuery中事件委托，我们首先需要了解事件冒泡的原理。 事件冒泡： 事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上，例如当点击某个事件时，处理该事件的函数并不在刚点击的事件源上，他就会向上冒泡到他的父级元素或祖先元素 事件监听的W3C规范语法：element.addEventListener(event, function, useCapture)event : （必需）事件名，支持所有 DOM事件 ；function：（必需）指定要事件触发时执行的函数；useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。当选择为true时，意味着停止冒泡，对我所产生的行为和我的父元素和祖先元素都没有关系，不要再向上通报他们了。事件冒泡和事件捕获意味着事件触发顺序不同，事件冒泡是从子到父，事件捕获是从父到子 1234567891011121314151617&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;item-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;item-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;item-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;item-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;item-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;item-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// 找到父元素，添加监听器...document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123; alert(&apos;我是大头爸爸&apos;); &#125;);document.getElementById(&quot;item-1&quot;).addEventListener(&quot;click&quot;,function(e) &#123; alert(&apos;我是小头儿子&apos;); &#125;);&lt;/script&gt; 结果： 而此时如果我们将useCapture置为true，则两个顺序会反过来，即先执行父元素上事件，后执行子元素上事件。 但是事件冒泡还是有自己的用武之地，例如就是上面的列表，当每个li被点击时，可能有各种各样的事件发生，如果我们对每一个子元素都进行监听，有时这些元素还会有删除新增，会比较麻烦，而使用事件委托，这件事就会变得比较简单。例如实现点击每个li的时候给被选中的li添加‘active’属性，就可以利用这一特性： 12345678910111213141516171819202122232425&lt;style type=&quot;text/css&quot;&gt; .active&#123; background: blue; &#125;&lt;/style&gt;&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;item-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;item-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;item-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;item-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;item-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;item-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&apos;#parent-list&apos;).on(&quot;click&quot;,function(e) &#123; // e.target是被点击的元素! // 如果被点击的是li元素 if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123; // 找到目标，给他添加active类 $(e.target).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); &#125;&#125;);&lt;/script&gt; 效果如图所示： 如何阻止事件冒泡使用事件对象的 stopPropagation 方法具体用法如下所示：1234//地址的编辑$(document).on(&apos;click&apos;,&apos;.address-update&apos;,function(e)&#123; e.stopPropagation();&#125;);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>事件冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的圣杯布局、双飞翼布局]]></title>
    <url>%2F2017%2F11%2F15%2FCSS%E7%9A%84%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局和双飞翼布局解决的问题：两边顶宽，中间自适应的三栏布局，中间栏要放在文档流前面先渲染 1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; 中间部分 &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.container&#123; padding: 0 200px; overflow: hidden;&#125;.middle&#123; width: 100%; height:200px; background-color: pink; float:left;&#125;.left&#123; width: 200px; height: 200px; background-color: grey; margin-left: -100%; float:left; position: relative; left: -200px;&#125;.right&#123; width: 200px; height: 200px; background-color: yellow; margin-left: -200px; float:left; position: relative; right: -200px;&#125; 两种布局在解决问题的前面部分是一致的，都是三栏全部浮动，左右两列加上负margin让其与中间div并排，并形成三栏布局 两者的不同在于 圣杯布局，为了中间div内容不被遮挡， 三者均设置左浮动； 设置middle的宽度为100%； 设置负边距，left负左边距设置100%，right负左边距为它本身的宽度 设置container左右的padding值给左右两个子面板留出空间 设置left和right为相对定位，position：relative，“left”的left值为负的”left”的宽度，“right”的right值为负的“right”宽度效果图存在的问题当中间部分的宽度小于两边的宽度时，布局就会乱掉 此时，双飞翼就驾着七彩祥云来了， 123456789&lt;body&gt;&lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inside&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627.middle&#123; width: 100%; height: 200px; float: left; background-color: pink;&#125;.inside&#123; margin:0 200px;&#125;.left&#123; width: 200px; height: 200px; float: left; margin-left: -100%; background-color: grey;&#125;.right&#123; width:200px; height: 200px; float: left; margin-left: -200px; background-color: yellow;&#125; 双飞翼布局是在middle的div里插入一个div,通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件委托、事件监听和事件绑定]]></title>
    <url>%2F2017%2F11%2F15%2F%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[事件委托、事件监听和事件绑定事件绑定：在javascript中，有三种常用的事件绑定的方法： DOM元素中直接绑定 Javascript添加事件的方法 事件监听函数 在HTML行间元素中直接绑定事件鼠标事件：onclick,ondbclick,onmouseover,onmousedown,onmouseup,onmousemove,onmouseout等键盘事件：onkeyup , onkeydown,onkeypress表单事件：onsubmit,onblur,onfocus 123456&lt;input type=&quot;button&quot; onclick = &quot;getSomething()&quot; /&gt;&lt;script&gt; function getSomething()&#123; alert(&apos;Something&apos;); &#125;&lt;/script&gt; 在JavaScript代码中绑定事件 123456&lt;input type=&quot;button&quot; id=&quot;btn&quot; /&gt;&lt;script&gt; document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&apos;Something&apos;); &#125;&lt;/script&gt; 事件监听使用addEventListener()或attachEvent()来绑定事件监听函数 出现事件监听的原因因为对于同一个对象使用前两种方式绑定多个方法的时候，后一个方法会把前一个方法覆盖，因此最后的效果只有最后一个方法的效果，举个例子： 123456789101112131415&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;click me!&quot; /&gt;&lt;script&gt; window.onload = function()&#123; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; alert(&quot;第一个事件&quot;); &#125; btn.onclick = function()&#123; alert(&quot;第二个事件&quot;); &#125; btn.onclick = function()&#123; alert(&quot;第三个事件&quot;); &#125; &#125;&lt;/script&gt; 结果如图： 使用addEventListener,即可触发两个事件 123456789101112var eventOne = function()&#123; alert(&quot;第一个监听事件&quot;); &#125; function eventTwo()&#123; alert(&quot;第二个监听事件&quot;); &#125; window.onload = function()&#123; var btn = document.getElementById(&quot;yuanEvent&quot;); //addEventListener：绑定函数 btn.addEventListener(&quot;click&quot;,eventOne); btn.addEventListener(&quot;click&quot;,eventTwo); &#125; 结果如图： 采用这样的方式绑定后，还可以解绑，即在上面的代码后面添加一条如下语句，即可解绑事件2 1btn.removeEventListener(&quot;click&quot;,eventTwo); 注意事项 解除绑定事件时要用函数的句柄，而不能把整个函数搬到那里，否则是无法解除绑定的 这样的写法是错误的：12btn.removeEventListener(&quot;click&quot;,function eventTwo()&#123; alert(&quot;第二个监听事件&quot;); 不会起作用 事件监听现有的规范W3c规范 W3C规范语法：element.addEventListener(event, function, useCapture)event : （必需）事件名，支持所有 DOM事件 ；function：（必需）指定要事件触发时执行的函数；useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。（这一块儿还不清楚，之后还会学习再来做补充） 事件委托（event delegation）事件委托就是利用冒泡的原理，把事件加到父元素或者祖先元素上 12345678&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;item-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;item-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;item-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;item-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;item-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;item-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 当每个子元素被点击时，将有各种各样的事件发生，如果我们对每一个子元素都进行监听，有时这些元素还会有删除新增，会比较麻烦，而使用事件委托，这件事就会变得比较简单。例如就是刚刚上面的一段代码 123456789// 找到父元素，添加监听器...document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e) &#123; // e.target是被点击的元素! // 如果被点击的是li元素 if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;) &#123; // 找到目标，输出ID! console.log(&quot;List &quot;+ e.target.id + &quot; was clicked!&quot;); &#125;&#125;); 就可以知道是哪个子元素被点击：]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>事件绑定</tag>
        <tag>事件委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+Github Pages搭建博客后如何发博文]]></title>
    <url>%2F2017%2F11%2F07%2Fhexo%2BGithubPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%91%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[打开博客本地文件夹, 然后右键运行git bush,输入： 1hexo new &apos;文章题目XXX&apos; 然后运行： 1hexo g(generate) 然后利用 1hexo server 来在本地查看效果，运行此条命令后会出现查看 http://localhost:4000 来查看本地效果的提示，如果你输入此url后一直在解析，则说明你的4000端口已被占用，可以换别的端口来查看效果例如： 1hexo s -p 5000 即可在localhost:5000查看 接着运行 1hexo d 即可]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现水平垂直居中]]></title>
    <url>%2F2017%2F11%2F07%2FCSS%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[css实现div垂直水平居中：方法一 margin：auto我们通常用margin 0 auto来实现居中，但是这样是无法实现垂直居中的，但其实稍微对此作一些修改就可以实现想要的效果，就是margin auto，代码如下css代码：12345.center &#123; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125; html代码： 1&lt;div class=&quot;center&quot;&gt;&lt;/div&gt; 方法二 负margin法我们首先用top:50%和left:50%让div的坐标原点（左上角）移动到整个浏览器中心，然后再利用负margin让它往左偏移自身宽的一半，再往上偏移自身高的一半，这样div的中心点就跟浏览器的中心点对齐了。css代码：12345678910111213.mainbody&#123; width: 400px; height: 200px; overflow: hidden; background-color: #ccc; position: absolute;&#125;#center&#123; top: 50%; left: 50%; margin-left: -200px; margin-top: -100px;&#125; html代码： 12&lt;div class=&quot;mainbody&quot; id=&quot;center&quot;&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
